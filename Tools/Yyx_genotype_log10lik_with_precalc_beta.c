
/*********************************************************************
 * Copyright (C) 2013 Center for Bioinformatics, Peking University, China
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
 * General Public License for more details.
 *
 * This program is used to calculate log10 genotype likelihood
 * ( L(G)=P(o|G,d,q) ) for each individual
 * Input includes beta function table (generated by generate_beta_log10_val_file.r)
 * and log10 L(r)=P(o|r,q) modeling baseQ (sequencing error part)
 * (generated by Yyx_real_log10lik_from_baseQ)
 *
 * Version: 0.5.1 (2014-01-14)\n");
 * Author: Adam Yongxin Ye @ CBI\n");
 *
 *********************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <float.h>
#include <unistd.h>

#define MIN(X,Y) ((X) < (Y) ? (X) : (Y))
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))

#define PRED_TO_LOG10PROB(phred) (-1.0*(phred)/10.0)
#define POW10(x) (pow(10.0, x))

#define LOGZERO -1e100 
#define MAX_LINE_LEN 100100

double log10_add_pow10(double a, double b);

double *yyx_calc_likelihood(int depth, const double *beta_log10_val, const double *real_log10prob_vec, double *tmp_four_double_vec);

/**
 * @brief Computes log10(10^(a) + 10^(b))
 */
double log10_add_pow10(double a, double b)
{
/*  in R code:
	tmp_max <- max(vec)
	log10(sum(10^(vec-tmp_max))) + tmp_max
*/
	if (a > b) {
		return a + log10(1+POW10(b-a));
//		return a + log1p(POW10(b-a))/log(10);
	} else {
		return b + log10(1+POW10(a-b));
//		return b + log1p(POW10(a-b))/log(10);
	}
}
/* end of log10_add_pow10() */


/**
 * @brief Computes genotype state likelihood
 *
 * calculate likelihood as R code below: 
 *
	ref_hom_likelihood=10^baseQ_on_real_altCount_ll[1]
	het_likelihood=10^(log10sum10exp(baseQ_on_real_altCount_ll))*0.5^depth
	alt_hom_likelihood=10^baseQ_on_real_altCount_ll[depth+1]
	somatic_likelihood=10^log10sum10exp(baseQ_on_real_altCount_ll + mosaic_bernoulli_on_real_altCount_ll)
 */
double *yyx_calc_likelihood(int depth, const double *beta_log10_val, const double *real_log10prob_vec, double *tmp_four_double_vec)
{
//	double alt_hom_log10_likelihood = real_log10prob_vec[depth];
	tmp_four_double_vec[2] = real_log10prob_vec[depth];
//	double ref_hom_log10_likelihood = real_log10prob_vec[0];
	tmp_four_double_vec[0] = real_log10prob_vec[0];
	double het_log10_likelihood = LOGZERO;
	double mosaic_log10_likelihood = LOGZERO;
	int i;
	for(i=0; i<=depth; i++){
		het_log10_likelihood = log10_add_pow10(het_log10_likelihood, real_log10prob_vec[i]);
		mosaic_log10_likelihood = log10_add_pow10(mosaic_log10_likelihood, real_log10prob_vec[i] + beta_log10_val[i]);
	}
//	het_log10_likelihood = het_log10_likelihood + depth * log10(0.5);
	tmp_four_double_vec[1] = het_log10_likelihood + depth * log10(0.5);
	tmp_four_double_vec[3] = mosaic_log10_likelihood;
//	het_log10_likelihood = log10(1) + depth * log10(0.5); 
	// This assignment above is theoretically correct, except for accumulation of calculation error in real_log10prob_vec
	// As observed, some beta_log10_val = -Inf
//	printf("likelihood: %f %f %f %f\n", ref_hom_log10_likelihood, het_log10_likelihood, alt_hom_log10_likelihood, mosaic_log10_likelihood);

	return tmp_four_double_vec;
}
/* end of yyx_calc_likelihood() */



int main(int argc, char* argv[])
{
	char usage_str[10000];
	sprintf(usage_str, "\nUsage: %s \n      <beta_log10_val.txt> <max_depth> <real_log10lik_from_baseQ.txt> \n", argv[0]);
	strcat(usage_str, "\n");
	strcat(usage_str, " * This program is used to calculate log10 genotype likelihood\n");
	strcat(usage_str, "   ( L(G)=P(o|G,d,q) ) for each individual\n");
	strcat(usage_str, " * Input includes beta function table\n");
	strcat(usage_str, "   (generated by generate_beta_log10_val_file.r)\n");
	strcat(usage_str, "   and log10 L(r)=P(o|r,q) modeling baseQ (sequencing error part)\n");
	strcat(usage_str, "   (generated by Yyx_real_log10lik_from_baseQ)\n");
	strcat(usage_str, "\n");
	strcat(usage_str, "  <beta_log10_val.txt> format:\n");
	strcat(usage_str, "      log10 values of beta function, \n");
	strcat(usage_str, "        separated by ',', no space is allowed, \n");
	strcat(usage_str, "        each row for one depth,\n");
	strcat(usage_str, "        can be generated by 'generate_beta_log10_val_file.R'\n");
	strcat(usage_str, "\n");
	strcat(usage_str, "  <max_depth>: an integer indicate how many lines \n");
	strcat(usage_str, "       should be loaded into memory from <beta_log10_val.txt>,\n");
	strcat(usage_str, "       which should be more than every depth in real seq data\n");
	strcat(usage_str, "         (<real_log10lik_from_baseQ.txt>)\n");
	strcat(usage_str, "       Note: more than 5500 may cause Segmentation fault!\n");
	strcat(usage_str, "\n");
	strcat(usage_str, "  <real_log10lik_from_baseQ.txt> format:\n");
	strcat(usage_str, "      ID + depth + log10 prob. for any 'real' alt count at the site,\n");
	strcat(usage_str, "        separated by ',', no space is allowed,\n");
	strcat(usage_str, "        can be generated by 'Yyx_real_log10lik_from_baseQ.v0_5_1.c'\n");
	strcat(usage_str, "\n");
	strcat(usage_str, "  output (stdout) format:\n");
	strcat(usage_str, "      ID + log10 likelihood of (ref_hom, het, alt_hom, mosaic) \n");
	strcat(usage_str, "        separated by '\\t'\n");
	strcat(usage_str, "\n");
	strcat(usage_str, "Version: 0.5.1 (2014-01-14)\n");
	strcat(usage_str, "Author: Adam Yongxin Ye @ CBI\n");
	strcat(usage_str, "\n");

	char beta_log10_val_filename[1000];
	char real_log10prob_vec_filename[1000];
	int max_depth;
	if(argc<4){
		fprintf(stderr, "%s", usage_str);
		return 1;
	}else{
		strcpy(beta_log10_val_filename, argv[1]);
		sscanf(argv[2], "%d", &max_depth);
		strcpy(real_log10prob_vec_filename, argv[3]);
	}
	
	char line[MAX_LINE_LEN];
	char *line_remain;
	
	// read in beta_log10_val file
	FILE *beta_file = fopen(beta_log10_val_filename, "r");
	if(beta_file==NULL){
		fprintf(stderr, "Error: cannot open beta_log10_val file '%s'\n", beta_log10_val_filename);
		return -1;
	}
	
	double **beta_log10_val_table;
	if((beta_log10_val_table = malloc((max_depth)*sizeof(double*)))==NULL){
		fprintf(stderr, "Error: cannot allocate memory at %d\n", __LINE__);
		return 2;
	}
	int depth;
	int i;
	char *each_item;
	for(depth=1; depth<=max_depth; depth++){
		if((beta_log10_val_table[depth-1] = malloc((depth+1)*sizeof(double)))==NULL){
			fprintf(stderr, "Error: cannot allocate memory at %d\n", __LINE__);
			return 3;
		}
		if(fscanf(beta_file, "%s", line)!=EOF){
			// split beta_vec line by ','
			i = 0;
			line_remain = line;
			each_item = strsep(&line_remain, ",");
			while (each_item != NULL){
//				printf("each_item = %s\n", each_item);
				if(i>depth){
					fprintf(stderr, "Warning: the line in beta_file has more item than needed (line %d)\n", depth);
					break;
				}
				if(sscanf(each_item, "%lf", &(beta_log10_val_table[depth-1][i])) < 1){
					// check '-Inf', change it to LOGZERO
					if(strcmp(each_item, "-Inf")==0){
						beta_log10_val_table[depth-1][i] = LOGZERO;
					}else{
						fprintf(stderr, "Warning: cannot recognize the item '%s' in beta_file (line %d, item %d)\n", each_item, depth, i+1);
						beta_log10_val_table[depth-1][i] = LOGZERO;
					}
				}
				i++;
				each_item = strsep(&line_remain, ",");
			}
		}else{
			fprintf(stderr, "Warning: beta_log10_val file does not contain %d lines. I have only read %d lines\n", max_depth, depth-1);
			max_depth = depth - 1;
			break;
		}
	}
	
	fclose(beta_file);
	
	// read in real_log10prob_vec file and log10_prior file, manipulate and output for each row
	FILE *real_vec_file = fopen(real_log10prob_vec_filename, "r");
	if(real_vec_file==NULL){
		fprintf(stderr, "Error: cannot open real_log10prob_vec file '%s'\n", real_log10prob_vec_filename);
		return -1;
	}
	
	long l = 0;
	double *real_vec;
//	double prior_vec[4];
	double likelihood_vec[4];
//	double posterior_vec[4];
	char chr_pos[1000];
//	char chr_pos_2[1000];
	while(fscanf(real_vec_file, "%s\t%d\t%s", chr_pos, &depth, line)!=EOF){
		l++;
		if(depth > max_depth){
			fprintf(stderr, "Warning: the line in real_vec_file has higher depth (%d) than max_depth (%d) (line %ld)\n", depth, max_depth, l);
			fprintf(stdout, "%s\tNA\tNA\tNA\tNA\n", chr_pos);
			continue;
		}
		
		if(depth<=0){
			fprintf(stderr, "Warning: the depth = 0 in real_vec_file (line %ld)\n", l);
			fprintf(stdout, "%s\tNA\tNA\tNA\tNA\n", chr_pos);
			continue;
		}
		
		if((real_vec = malloc((depth+1)*sizeof(double)))==NULL){
			fprintf(stderr, "Error: cannot allocate memory at %d\n", __LINE__);
			return 4;
		}
		
		// split real_vec line by ','
		i = 0;
		line_remain = line;
		each_item = strsep(&line_remain, ",");
		while (each_item != NULL){
			if(i>depth){
				fprintf(stderr, "Warning: the line in real_vec_file has more item than needed (line %ld)\n", l);
				break;
			}
			if(sscanf(each_item, "%lf", &(real_vec[i])) < 1){
				fprintf(stderr, "Warning: cannot recognize the item '%s' in real_vec_file (line %ld, item %d)\n", each_item, l, i+1);
				real_vec[i] = LOGZERO;
			}
			i++;
			each_item = strsep(&line_remain, ",");
		}
		
		// calculate prior and posterior
//			yyx_calc_prior(allele_freq, mosaic_prior, prior_vec);
		yyx_calc_likelihood(depth, beta_log10_val_table[depth-1], real_vec, likelihood_vec);
//		yyx_calc_posterior(prior_vec, likelihood_vec, posterior_vec);
		
		// output to stdout
		fprintf(stdout, "%s\t%.5f\t%.5f\t%.5f\t%.5f\n", chr_pos, likelihood_vec[0], likelihood_vec[1], likelihood_vec[2], likelihood_vec[3]);
		fflush(stdout);
		
		free(real_vec);
	}
	
	fclose(real_vec_file);
	
	
	// clean up heap (malloc)
	for(depth=1; depth<=max_depth; depth++){
		free(beta_log10_val_table[depth-1]);
	}
	free(beta_log10_val_table);
	
	
	return 0;
}
